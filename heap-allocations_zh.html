<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>堆分配 - Rust性能优化</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Title Page</a></li><li class="chapter-item expanded "><a href="introduction_zh.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="benchmarking_zh.html"><strong aria-hidden="true">2.</strong> 基准分析</a></li><li class="chapter-item expanded "><a href="build-configuration_zh.html"><strong aria-hidden="true">3.</strong> 构建配置</a></li><li class="chapter-item expanded "><a href="linting_zh.html"><strong aria-hidden="true">4.</strong> 语言分析</a></li><li class="chapter-item expanded "><a href="profiling_zh.html"><strong aria-hidden="true">5.</strong> 性能分析</a></li><li class="chapter-item expanded "><a href="inlining_zh.html"><strong aria-hidden="true">6.</strong> 内联</a></li><li class="chapter-item expanded "><a href="hashing_zh.html"><strong aria-hidden="true">7.</strong> 散列</a></li><li class="chapter-item expanded "><a href="heap-allocations_zh.html" class="active"><strong aria-hidden="true">8.</strong> 堆分配</a></li><li class="chapter-item expanded "><a href="type-sizes_zh.html"><strong aria-hidden="true">9.</strong> 类型大小</a></li><li class="chapter-item expanded "><a href="standard-library-types_zh.html"><strong aria-hidden="true">10.</strong> 标准库类型</a></li><li class="chapter-item expanded "><a href="iterators_zh.html"><strong aria-hidden="true">11.</strong> 迭代器</a></li><li class="chapter-item expanded "><a href="io_zh.html"><strong aria-hidden="true">12.</strong> I/O</a></li><li class="chapter-item expanded "><a href="logging-and-debugging_zh.html"><strong aria-hidden="true">13.</strong> 日志和调试</a></li><li class="chapter-item expanded "><a href="wrapper-types_zh.html"><strong aria-hidden="true">14.</strong> 包装类型</a></li><li class="chapter-item expanded "><a href="machine-code_zh.html"><strong aria-hidden="true">15.</strong> 机器代码</a></li><li class="chapter-item expanded "><a href="parallelism_zh.html"><strong aria-hidden="true">16.</strong> 并发</a></li><li class="chapter-item expanded "><a href="general-tips_zh.html"><strong aria-hidden="true">17.</strong> 通用提示</a></li><li class="chapter-item expanded "><a href="compile-times_zh.html"><strong aria-hidden="true">18.</strong> 编译时间</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust性能优化</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/poly000/perf-book-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="堆分配"><a class="header" href="#堆分配">堆分配</a></h1>
<p>堆分配的代价不高。具体细节取决于使用的分配器，但每次分配和deallocation通常都需要获取一个全局锁，做一些非平凡的数据结构操作。并可能执行一个系统调用。小分配不一定比大分配便宜。值得了解哪些Rust数据结构和操作会导致分配，因为避免它们可以大大提高性能。</p>
<p><a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/">Rust Container Cheat Sheet</a>有常见的Rust类型的可视化，是下面章节的绝佳配套。</p>
<h2 id="性能分析"><a class="header" href="#性能分析">性能分析</a></h2>
<p>如果通用性能分析器显示 “malloc”、”free”和相关函数为热函数，那么很可能值得尝试降低分配率或使用其他分配器。</p>
<p><a href="https://www.valgrind.org/docs/manual/dh-manual.html">DHAT</a>是降低分配率时可以使用的一个优秀的剖析器。它在Linux和一些Unix系统上可用。它能精确地识别热分配点及其分配率。确切的结果会有所不同，但使用rustc的经验表明，每减少10分配每百万指令率可以有可衡量的性能改进（例如，约1%）。</p>
<p>下面是DHAT的一些输出示例。</p>
<pre><code class="language-text">AP 1.1/25 (2 children) {
  Total:     54,533,440 bytes (4.02%, 2,714.28/Minstr) in 458,839 blocks (7.72%, 22.84/Minstr), avg size 118.85 bytes, avg lifetime 1,127,259,403.64 instrs (5.61% of program duration)
  At t-gmax: 0 bytes (0%) in 0 blocks (0%), avg size 0 bytes
  At t-end:  0 bytes (0%) in 0 blocks (0%), avg size 0 bytes
  Reads:     15,993,012 bytes (0.29%, 796.02/Minstr), 0.29/byte
  Writes:    20,974,752 bytes (1.03%, 1,043.97/Minstr), 0.38/byte
  Allocated at {
    #1: 0x95CACC9: alloc (alloc.rs:72)
    #2: 0x95CACC9: alloc (alloc.rs:148)
    #3: 0x95CACC9: reserve_internal&lt;syntax::tokenstream::TokenStream,alloc::alloc::Global&gt; (raw_vec.rs:669)
    #4: 0x95CACC9: reserve&lt;syntax::tokenstream::TokenStream,alloc::alloc::Global&gt; (raw_vec.rs:492)
    #5: 0x95CACC9: reserve&lt;syntax::tokenstream::TokenStream&gt; (vec.rs:460)
    #6: 0x95CACC9: push&lt;syntax::tokenstream::TokenStream&gt; (vec.rs:989)
    #7: 0x95CACC9: parse_token_trees_until_close_delim (tokentrees.rs:27)
    #8: 0x95CACC9: syntax::parse::lexer::tokentrees::&lt;impl syntax::parse::lexer::StringReader&lt;'a&gt;&gt;::parse_token_tree (tokentrees.rs:81)
  }
}
</code></pre>
<p>在这个例子中，介绍所有的内容已经超出了本书的范围，但应该清楚的是，DHAT给出了大量关于分配的信息，比如它们发生的地点和频率，它们的规模有多大，它们的寿命有多长，以及它们被访问的频率。</p>
<h2 id="box"><a class="header" href="#box"><code>Box</code></a></h2>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>是最简单的堆分配类型。<code>Box&lt;T&gt;</code>值是一个在堆上分配的<code>T</code>值。</p>
<p>有时值得将结构体或枚举字段中的一个或多个字段装箱，以使类型更小。(更多信息请参见 <a href="type-sizes.html">Type Sizes</a> 一章)。</p>
<p>除此之外，<code>Box</code>是直接的，并没有提供太多优化的空间。</p>
<h2 id="rcarc"><a class="header" href="#rcarc"><code>Rc</code>/<code>Arc</code></a></h2>
<p>[<code>Rc</code>]/[<code>Arc</code>]类似于<code>Box</code>，但堆上的值有两个引用计数。它们允许值共享，这可以是减少内存使用的有效方法。</p>
<p>[<code>Rc</code>]：https://doc.rust-lang.org/std/rc/struct.Rc.html
[Arc]：https://doc.rust-lang.org/std/sync/struct.Arc.html</p>
<p>但是，如果用于很少共享的值，它们可以通过堆分配本来可能不会被堆分配的值来提高分配率。
<a href="https://github.com/rust-lang/rust/pull/37373/commits/c440a7ae654fb641e68a9ee53b03bf3f7133c2fe"><strong>Example</strong></a>。</p>
<p>与<code>Box</code>不同的是，在<code>Rc</code>/<code>Arc</code>值上调用<code>clone</code>并不涉及分配。相反，它只是增加一个引用计数。</p>
<h2 id="vec"><a class="header" href="#vec"><code>Vec</code></a></h2>
<p>[<code>Vec</code>]是一种堆分配类型，在优化分配数量和/或尽量减少浪费的空间方面有很大的空间。要做到这一点，需要了解其元素的存储方式。</p>
<p>[<code>Vec</code>]：https://doc.rust-lang.org/std/vec/struct.Vec.html</p>
<p>一个 “Vec “包含三个词：一个长度、一个容量和一个指针。如果容量是非零，元素大小是非零，指针将指向堆分配的内存；否则，它将不指向分配的内存。</p>
<p>即使 “Vec” 自身不是堆分配的，元素（如果存在且大小非零）也会是堆分配的。如果存在非零大小的元素，那么存放这些元素的内存可能会比必要的大，为未来的元素提供空间。存在的元素数就是长度，不需要重新分配就可以容纳的元素数就是容量。</p>
<p>当向量需要增长到超过其当前容量时，元素将被复制到一个更大的堆分配中，旧的堆分配将被释放。</p>
<h3 id="vec-增长"><a class="header" href="#vec-增长"><code>Vec</code> 增长</a></h3>
<p>用普通方法创建一个新的、空的<code>Vec</code>。
(<a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec![]</code></a> 或 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.new"><code>Vec::new</code></a> 或 <a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default"><code>Vec::default</code></a>）的长度和容量为零，不需要进行堆分配。如果你反复将单个元素推到<code>Vec</code>的末端，它将周期性地重新分配。增长策略没有被指定，但在写这篇文章的时候，它使用了一个准双倍策略，结果是以下容量。0, 4, 8, 16, 32, 64, 等等. (它直接从0跳到4，而不是通过1和2，因为这在实践中<a href="https://github.com/rust-lang/rust/pull/72227">避免了许多分配</a>。) 随着向量的增长，重新分配的频率将以指数形式减少，但可能浪费的多余容量将以指数形式增加。</p>
<p>这种增长策略对于可增长的数据结构来说是典型的，在一般情况下是合理的，但如果你事先知道一个向量的可能长度，你可以做的往往更好。如果你有一个热向量分配站点（例如一个热的 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.push"><code>Vec::push</code></a>调用），值得使用<a href="https://doc.rust-lang.org/std/macro.eprintln.html"><code>eprintln!</code></a>来打印该站点的向量长度，然后做一些后处理（例如使用<a href="https://github.com/nnethercote/counts/"><code>counts</code></a>）来确定长度分布。例如，你可能有很多短向量，也可能有较少的超长向量，优化分配站点的最佳方式也会相应变化。</p>
<h3 id="短-vec"><a class="header" href="#短-vec">短 <code>Vec</code></a></h3>
<p>如果你有很多短向量，你可以使用<a href="https://crates.io/crates/smallvec"><code>smallvec</code></a>crate中的<code>SmallVec</code>类型。<code>SmallVec&lt;[T;N]&gt;</code>是<code>Vec</code>的替代物，它可以在<code>SmallVec</code>本身中存储<code>N</code>个元素，如果元素数量超过这个数量，就会切换到堆分配。(还需要注意的是，<code>vec![]</code>字元必须用<code>smallvec![]</code>字元代替。)
<a href="https://github.com/rust-lang/rust/pull/50565/commits/78262e700dc6a7b57e376742f344e80115d2d3f2"><strong>Example 1</strong></a>,
<a href="https://github.com/rust-lang/rust/pull/55383/commits/526dc1421b48e3ee8357d58d997e7a0f4bb26915"><strong>Example 2</strong></a>.</p>
<p><code>SmallVec</code>如果使用得当，可以可靠地降低分配率，但使用它并不能保证提高性能。对于正常的操作，它比<code>Vec</code>稍慢，因为它必须总是检查元素是否被堆分配。另外，如果<code>N</code>很高或者<code>T</code>很大，那么<code>SmallVec&lt;[T; N]&gt;</code>本身就会比<code>Vec&lt;T&gt;</code>大，复制<code>SmallVec</code>值的速度会比较慢。和以往一样，需要通过基准测试来确认优化是否有效。</p>
<p>如果你有很多短向量，并且你精确地知道它们的最大长度，[arrayvec]包中的ArrayVec比SmallVec更好。它不需要回落到堆分配，这使得它更快一些。
<a href="https://github.com/rust-lang/rust/pull/74310/commits/c492ca40a288d8a85353ba112c4d38fe87ef453e"><strong>Example</strong></a>.</p>
<h3 id="更长的-vec"><a class="header" href="#更长的-vec">更长的 <code>Vec</code></a></h3>
<p>如果你知道一个向量的最小或精确大小，你可以用<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.with_capacity"><code>Vec::with_capacity</code></a>、<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.reserve"><code>Vec::reserve</code></a>或<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.reserve_exact"><code>Vec::reserve_exact</code></a>来保留一个特定的容量。例如，如果你知道一个向量将成长为至少有20个元素，这些函数可以使用一次分配立即提供一个至少有20个容量的向量，而一次推送一个项目将导致四次分配（对于4、8、16和32的容量）。
<a href="https://github.com/rust-lang/rust/pull/77990/commits/a7f2bb634308a5f05f2af716482b67ba43701681"><strong>Example</strong></a>.</p>
<p>如果你知道一个向量的最大长度，上述函数也可以让你不分配多余的不必要的空间。同样，<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.shrink_to_fit"><code>Vec::shrink_to_fit</code></a>也可以用来尽量减少浪费的空间，但要注意它可能会引起重新分配。</p>
<h2 id="string"><a class="header" href="#string"><code>String</code></a></h2>
<p>一个<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>包含堆分配的字节。<code>String</code>的表示和操作与<code>Vec&lt;u8&gt;</code>非常相似。许多与增长和容量有关的<code>Vec</code>方法与<code>String</code>有对应关系，如<a href="https://doc.rust-lang.org/std/string/struct.String.html#method.with_capacity"><code>String::with_capacity</code></a>。</p>
<p>来自<a href="https://crates.io/crates/smallstr"><code>smallstr</code></a>包的<code>SmallString</code>类型与<code>SmallVec</code>类型类似。</p>
<p>来自 <a href="https://crates.io/crates/smartstring"><code>smartstring</code></a> crate的 <code>String</code> 类型是<code>String</code>的插入式实现，
避免了少于三个 “字” 的<code>String</code>进行堆分配。 在64位平台上，这通常是任意少于24字节的字符串，
包括了所有含有23个或更少ASCII字符的字符串。
<a href="https://github.com/djc/topfew-rs/commit/803fd566e9b889b7ba452a2a294a3e4df76e6c4c"><strong>Example</strong></a>.</p>
<p>请注意，<code>format!</code>宏产生一个<code>String</code>，这意味着它进行了分配。如果你能通过使用字符串文字来避免<code>format!</code>的调用，就能避免这种分配。
<a href="https://github.com/rust-lang/rust/pull/55905/commits/c6862992d947331cd6556f765f6efbde0a709cf9"><strong>Example</strong></a>.</p>
<h2 id="散列表"><a class="header" href="#散列表">散列表</a></h2>
<p><a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html"><code>HashSet</code></a>和<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>是散列表。在分配方面，它们的表示和操作与<code>Vec</code>的表示和操作相似：它们有一个单一的连续的堆分配，存放键和值，随着表的增长，必要时重新分配。许多与增长和容量有关的<code>Vec</code>方法都有与<code>HashSet</code>/<code>HashMap</code>对应的方法，如<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.with_capacity"><code>HashSet::with_capacity</code></a>。</p>
<h2 id="cow"><a class="header" href="#cow"><code>Cow</code></a></h2>
<p>有时候你有一些借用数据，比如<code>&amp;str</code>，大部分是只读的，但偶尔需要修改。每次都克隆数据会很浪费。相反，你可以通过<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a>类型使用 “write-on-clone “语义，它既可以表示借来的数据，也可以表示拥有的数据。</p>
<p>通常情况下，当从一个借来的值<code>x</code>开始时，你用<code>Cow::Borrowed(x)</code>把它包在一个<code>Cow</code>中。因为<code>Cow</code>实现了<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>，所以你可以直接在它所包含的数据上调用非修改的方法。如果需要修改，<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html#method.to_mut"><code>Cow::to_mut</code></a>将获得一个对所拥有的值的可修改引用，必要时进行克隆。</p>
<p><code>Cow</code>的工作可能会很麻烦，但它往往是值得的。
<a href="https://github.com/rust-lang/rust/pull/37064/commits/b043e11de2eb2c60f7bfec5e15960f537b229e20"><strong>Example 1</strong></a>,
<a href="https://github.com/rust-lang/rust/pull/50855/commits/ad471452ba6fbbf91ad566dc4bdf1033a7281811"><strong>Example 2</strong></a>,
<a href="https://github.com/rust-lang/rust/pull/56336/commits/787959c20d062d396b97a5566e0a766d963af022"><strong>Example 3</strong></a>,
<a href="https://github.com/rust-lang/rust/pull/68848/commits/67da45f5084f98eeb20cc6022d68788510dc832a"><strong>Example 4</strong></a>.</p>
<h2 id="clone"><a class="header" href="#clone"><code>clone</code></a></h2>
<p>在一个包含堆分配内存的值上调用[clone]通常会涉及额外的分配。例如，在一个非空的<code>Vec</code>上调用<code>clone</code>，需要对元素进行新的分配（但请注意，新<code>Vec</code>的容量可能与原<code>Vec</code>的容量不同）。例外的情况是<code>Rc</code>/<code>Arc</code>，<code>clone</code>的调用只是增加引用数。</p>
<p><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#method.clone_from"><code>clone_from</code></a>是<code>clone</code>的替代方法。<code>a.clone_from(&amp;b)</code>相当于<code>a = b.clone()</code>，但可以避免不必要的分配。例如，如果你想在一个现有的<code>Vec</code>之上克隆一个<code>Vec</code>，现有<code>Vec</code>的堆分配将尽可能地被重复使用，如下例所示。</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v1: Vec&lt;u32&gt; = Vec::with_capacity(99);
let v2: Vec&lt;u32&gt; = vec![1, 2, 3];
v1.clone_from(&amp;v2); // v1's allocation is reused
assert_eq!(v1.capacity(), 99);
<span class="boring">}
</span></code></pre></pre>
<p>虽然<code>clone</code>通常会造成分配，但在很多情况下使用它是一件很合理的事情，往往可以使代码更简单。使用剖析数据来查看哪些<code>clone</code>调用是热门的，值得花力气去避免。</p>
<p>有时，由于(a)程序员的错误，或(b)代码中的变化，使以前必要的<code>clone</code>调用变得不必要，Rust代码最终会包含不必要的<code>clone</code>调用。如果你看到一个似乎没有必要的热<code>clone</code>调用，有时可以简单地删除它。
<a href="https://github.com/rust-lang/rust/pull/37318/commits/e382267cfb9133ef12d59b66a2935ee45b546a61"><strong>Example 1</strong></a>,
<a href="https://github.com/rust-lang/rust/pull/37705/commits/11c1126688bab32f76dbe1a973906c7586da143f"><strong>Example 2</strong></a>,
<a href="https://github.com/rust-lang/rust/pull/64302/commits/36b37e22de92b584b9cf4464ed1d4ad317b798be"><strong>Example 3</strong></a>.</p>
<h2 id="to_owned"><a class="header" href="#to_owned"><code>to_owned</code></a></h2>
<p><code>ToOwned::to_owned</code>]是为许多常见类型实现的。它从借来的数据中创建拥有的数据，通常是通过克隆的方式，因此经常会引起堆分配。例如，它可以用来从一个<code>&amp;str</code>创建一个<code>String</code>。</p>
<p>有时，可以通过在结构中存储对借入数据的引用而不是自有副本来避免<code>to_owned</code>调用。这需要在结构体上做终身注解，使代码复杂化，只有在分析和基准测试表明值得时才可以这样做。
<a href="https://github.com/rust-lang/rust/pull/50855/commits/6872377357dbbf373cfd2aae352cb74cfcc66f34"><strong>Example</strong></a>.</p>
<h2 id="重用集合"><a class="header" href="#重用集合">重用集合</a></h2>
<p>有时你需要分阶段建立一个集合，如<code>Vec</code>。通常情况下，通过修改一个<code>Vec</code>比建立多个<code>Vec</code>然后将它们组合起来更好。</p>
<p>例如，如果你有一个函数 “do_stuff”，产生一个 “Vec”，可能会被多次调用。</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_stuff(x: u32, y: u32) -&gt; Vec&lt;u32&gt; {
    vec![x, y]
}
<span class="boring">}
</span></code></pre></pre>
<p>It might be better to instead modify a passed-in <code>Vec</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_stuff(x: u32, y: u32, vec: &amp;mut Vec&lt;u32&gt;) {
    vec.push(x);
    vec.push(y);
}
<span class="boring">}
</span></code></pre></pre>
<p>有时，值得保留一个可以重复使用的 “主力”集合。例如，如果一个循环的每次迭代都需要一个<code>Vec</code>，你可以在循环外声明<code>Vec</code>，在循环体中使用它，然后在循环体结束时调用<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.clear"><code>clear</code></a>（清空<code>Vec</code>而不影响它的容量）。这避免了分配，但代价是掩盖了一个事实，即每次迭代对<code>Vec</code>的使用与其他迭代无关。
<a href="https://github.com/rust-lang/rust/pull/77990/commits/45faeb43aecdc98c9e3f2b24edf2ecc71f39d323"><strong>Example 1</strong></a>,
<a href="https://github.com/rust-lang/rust/pull/51870/commits/b0c78120e3ecae5f4043781f7a3f79e2277293e7"><strong>Example 2</strong></a>.</p>
<p>同样，有时值得在一个结构中保留一个 “主力 “集合，以便在一个或多个被重复调用的方法中重用。</p>
<h2 id="使用其他分配器"><a class="header" href="#使用其他分配器">使用其他分配器</a></h2>
<p>另一个提高分配量大的Rust程序性能的选择是用一个替代分配器代替默认的（系统）分配器。确切的效果将取决于单个程序和选择的替代分配器。在不同的平台上，它也会有所不同，因为每个平台的系统分配器都有自己的优势和弱点。使用替代分配器也会影响二进制大小。</p>
<p>一个流行的替代分配器是<a href="https://github.com/jemalloc/jemalloc">jemalloc</a>，可通过 <a href="https://crates.io/crates/jemallocator"><code>jemallocator</code></a>包。要使用它，请在你的<code>Cargo.toml</code>文件中添加一个依赖关系。</p>
<pre><code class="language-toml">[dependencies]
jemallocator = &quot;0.3.2&quot;
</code></pre>
<p>然后在你的Rust代码中添加以下内容。</p>
<pre><code class="language-rust ignore">#[global_allocator]
static GLOBAL: jemallocator::Jemalloc = jemallocator::Jemalloc;
</code></pre>
<p>另一个可供选择的分配器是<a href="https://github.com/microsoft/mimalloc">mimalloc</a>，可通过<a href="https://docs.rs/mimalloc/0.1.22/mimalloc/"><code>mimalloc</code></a>板房使用。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="hashing_zh.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="type-sizes_zh.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="hashing_zh.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="type-sizes_zh.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
